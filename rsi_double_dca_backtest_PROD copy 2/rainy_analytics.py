"""
Rainy Day Analytics Generator
==============================

This module generates comprehensive rainy day buy analytics from backtest data
and saves it to a JSON file for modular consumption by HTML emails and other scripts.

SINGLE SOURCE OF TRUTH for rainy day analytics:
- Reads from rainy_buys_calendar_dates.csv (generated by backtest)
- Calculates all rainy pool metrics
- Exports to rainy_analytics.json
- HTML email and other scripts read from JSON (not CSV)

Usage:
    from rainy_analytics import generate_rainy_analytics, load_rainy_analytics
    
    # Generate fresh analytics from CSV
    generate_rainy_analytics()
    
    # Load analytics from JSON
    analytics = load_rainy_analytics()
"""

import json
import pandas as pd
from pathlib import Path
from datetime import datetime


def generate_rainy_analytics(
    csv_path: str = None,
    json_path: str = None,
    current_spy_price: float = None
) -> dict:
    """
    Generate comprehensive rainy day analytics from CSV data.
    
    Args:
        csv_path: Path to rainy_buys_calendar_dates.csv (default: auto-detect)
        json_path: Path to save rainy_analytics.json (default: auto-detect)
        current_spy_price: Current SPY price for ROI calculation (default: fetch latest)
    
    Returns:
        dict: Complete rainy day analytics
    """
    # Auto-detect paths
    if csv_path is None:
        csv_path = Path(__file__).parent / "rainy_buys_calendar_dates.csv"
    else:
        csv_path = Path(csv_path)
    
    if json_path is None:
        json_path = Path(__file__).parent / "rainy_analytics.json"
    else:
        json_path = Path(json_path)
    
    # Load rainy buys data
    if not csv_path.exists():
        print(f"⚠️  Warning: {csv_path} not found. Returning empty analytics.")
        return _empty_analytics()
    
    df = pd.read_csv(csv_path)
    
    if df.empty:
        print("⚠️  Warning: No rainy buys in CSV. Returning empty analytics.")
        return _empty_analytics()
    
    # Get current SPY price if not provided
    if current_spy_price is None:
        try:
            import yfinance as yf
            spy_data = yf.download('SPY', period='1d', progress=False)
            if not spy_data.empty:
                current_spy_price = float(spy_data['Close'].iloc[-1])
            else:
                current_spy_price = 0.0
        except Exception as e:
            print(f"⚠️  Could not fetch current SPY price: {e}")
            current_spy_price = 0.0
    
    # Calculate overall rainy pool metrics
    total_contributions = float(df['amount'].sum())
    num_buys = len(df)
    avg_buy_price = float(df['price'].mean())
    
    # Calculate shares and current value
    df['shares'] = df['amount'] / df['price']
    total_shares = float(df['shares'].sum())
    current_value = total_shares * current_spy_price if current_spy_price > 0 else 0.0
    profit = current_value - total_contributions
    roi_percent = (profit / total_contributions * 100) if total_contributions > 0 else 0.0
    price_appreciation_multiple = (current_spy_price / avg_buy_price) if avg_buy_price > 0 else 0.0
    
    # Calculate by year/period
    df['date'] = pd.to_datetime(df['date'])
    df['year'] = df['date'].dt.year
    
    periods_data = []
    for year in sorted(df['year'].unique()):
        year_df = df[df['year'] == year]
        year_contributions = float(year_df['amount'].sum())
        year_shares = float(year_df['shares'].sum())
        year_value = year_shares * current_spy_price if current_spy_price > 0 else 0.0
        year_profit = year_value - year_contributions
        year_roi = (year_profit / year_contributions * 100) if year_contributions > 0 else 0.0
        
        # Calculate period duration
        start_date = year_df['date'].min()
        end_date = year_df['date'].max()
        duration_days = (end_date - start_date).days
        
        periods_data.append({
            'year': int(year),
            'num_buys': int(len(year_df)),
            'total_contributions': round(year_contributions, 2),
            'avg_price': round(float(year_df['price'].mean()), 2),
            'total_shares': round(year_shares, 2),
            'current_value': round(year_value, 2),
            'profit': round(year_profit, 2),
            'roi_percent': round(year_roi, 2),
            'start_date': start_date.strftime('%Y-%m-%d'),
            'end_date': end_date.strftime('%Y-%m-%d'),
            'duration_days': int(duration_days)
        })
    
    # Sort periods by ROI descending
    periods_sorted_by_roi = sorted(periods_data, key=lambda x: x['roi_percent'], reverse=True)
    
    # Recent periods (last 5 years)
    current_year = datetime.now().year
    recent_periods = [p for p in periods_sorted_by_roi if p['year'] >= current_year - 5]
    
    # Top performing periods (all time)
    top_periods = periods_sorted_by_roi[:5]
    
    # Build analytics object
    analytics = {
        'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'current_spy_price': round(current_spy_price, 2),
        'data_source': str(csv_path.name),
        
        'summary': {
            'total_contributions': round(total_contributions, 2),
            'num_buys': num_buys,
            'avg_buy_price': round(avg_buy_price, 2),
            'total_shares': round(total_shares, 2),
            'current_value': round(current_value, 2),
            'profit': round(profit, 2),
            'roi_percent': round(roi_percent, 2),
            'price_appreciation_multiple': round(price_appreciation_multiple, 2),
            'first_buy_date': df['date'].min().strftime('%Y-%m-%d'),
            'last_buy_date': df['date'].max().strftime('%Y-%m-%d'),
            'years_active': len(df['year'].unique())
        },
        
        'all_periods': periods_sorted_by_roi,
        'top_periods': top_periods,
        'recent_periods': recent_periods,
        
        'individual_buys': [
            {
                'date': row['date'].strftime('%Y-%m-%d'),
                'rsi_sma': round(float(row['rsi_sma']), 2),
                'price': round(float(row['price']), 2),
                'amount': round(float(row['amount']), 2),
                'shares': round(float(row['shares']), 4),
                'current_value': round(float(row['shares']) * current_spy_price, 2) if current_spy_price > 0 else 0.0,
                'profit': round(float(row['shares']) * current_spy_price - float(row['amount']), 2) if current_spy_price > 0 else 0.0,
                'roi_percent': round((float(row['shares']) * current_spy_price - float(row['amount'])) / float(row['amount']) * 100, 2) if current_spy_price > 0 else 0.0
            }
            for _, row in df.iterrows()
        ]
    }
    
    # Save to JSON
    with open(json_path, 'w') as f:
        json.dump(analytics, f, indent=2)
    
    print(f"✅ Generated rainy analytics: {json_path}")
    print(f"   Total contributions: ${analytics['summary']['total_contributions']:,.2f}")
    print(f"   Current value: ${analytics['summary']['current_value']:,.2f}")
    print(f"   ROI: {analytics['summary']['roi_percent']:.2f}%")
    
    return analytics


def load_rainy_analytics(json_path: str = None) -> dict:
    """
    Load rainy day analytics from JSON file.
    
    Args:
        json_path: Path to rainy_analytics.json (default: auto-detect)
    
    Returns:
        dict: Rainy day analytics
    """
    if json_path is None:
        json_path = Path(__file__).parent / "rainy_analytics.json"
    else:
        json_path = Path(json_path)
    
    if not json_path.exists():
        print(f"⚠️  Warning: {json_path} not found. Generating fresh analytics...")
        return generate_rainy_analytics()
    
    with open(json_path, 'r') as f:
        analytics = json.load(f)
    
    return analytics


def _empty_analytics() -> dict:
    """Return empty analytics structure."""
    return {
        'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'current_spy_price': 0.0,
        'data_source': 'none',
        'summary': {
            'total_contributions': 0.0,
            'num_buys': 0,
            'avg_buy_price': 0.0,
            'total_shares': 0.0,
            'current_value': 0.0,
            'profit': 0.0,
            'roi_percent': 0.0,
            'price_appreciation_multiple': 0.0,
            'first_buy_date': '',
            'last_buy_date': '',
            'years_active': 0
        },
        'all_periods': [],
        'top_periods': [],
        'recent_periods': [],
        'individual_buys': []
    }


if __name__ == "__main__":
    # Generate analytics when run directly
    print("=" * 80)
    print("GENERATING RAINY DAY ANALYTICS")
    print("=" * 80)
    print()
    
    analytics = generate_rainy_analytics()
    
    print()
    print("=" * 80)
    print("SUMMARY")
    print("=" * 80)
    print(f"Total Rainy Buys: {analytics['summary']['num_buys']}")
    print(f"Total Contributions: ${analytics['summary']['total_contributions']:,.2f}")
    print(f"Current Value: ${analytics['summary']['current_value']:,.2f}")
    print(f"Profit: ${analytics['summary']['profit']:,.2f}")
    print(f"ROI: {analytics['summary']['roi_percent']:.2f}%")
    print()
    print("Top 5 Performing Years:")
    for i, period in enumerate(analytics['top_periods'], 1):
        print(f"  {i}. {period['year']}: {period['roi_percent']:.1f}% ROI (${period['profit']:,.0f} profit)")
    print()
    print("=" * 80)
